<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Atlas Frontend</title>

  <script src="https://unpkg.com/vue"></script>
  <script src="https://unpkg.com/vuex"></script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js"
          integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
          crossorigin="anonymous"></script>
  <script
      src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

  <link
      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
      media="all" rel="stylesheet"/>
  <link href="src/css/env-dropdown.css" media="all" rel="stylesheet"/>

  <link rel="import" href="src/partials/navbar.html">
  <link rel="import" href="src/partials/listing.html">
  <link rel="import" href="src/partials/row.html">
  <link rel="import" href="src/partials/confirm-button.html">
</head>
<body>
<div id="atlas-navbar">
  <atlas-navbar
      :routes="routes"
      :environments="environments">
  </atlas-navbar>
</div>
<div class="page container">
  <message-area id="alert" :messages="messages" v-if="messages.length > 0"></message-area>
<div id="site-listing" class="row">
  <form id="search" class="row">
    <div class="form-group">
      <label for="query">Search Statistics</label>
      <input id="query" class="form-control" name="query"
             v-model="searchQuery">
    </div>
    <div class="form-group">
      <button class="btn btn-primary" @click.prevent="search(searchQuery)">Search</button>
      <button class="btn btn-default" v-if="reset" @click.prevent="resetSearch()">Reset</button>
    </div>
  </form>
  <div class="row">
    <listing
        :data="gridData"
        :columns="gridColumns"
        :filter-key="searchQuery"
        :edit-keys="editKeys"
        :select-keys="selectKeys"
        :callback="callback">
    </listing>
  </div>
</div>
<div id="create-site" class="row">
  <confirm-button
      :label="label"
      :callback="callback">
  </confirm-button>
</div>
</div>
<script src="src/config/config.js"></script>
<script src="src/config/routes.js"></script>
<script src="src/js/utilities.js"></script>
<script src="src/js/components.js"></script>
<script src="src/js/navbar.js"></script>
<script src="src/js/site-records.js"></script>
<script src="src/js/code-records.js"></script>
<script type="text/javascript">
  /**
   * Imports Site Listing HTML into DOM of pages using it.
   *
   * @type {Element}
   */
  var link = document.querySelector('link[href="src/partials/listing.html"]');
  var content = link.import;
  var el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  var link = document.querySelector('link[href="src/partials/row.html"]');
  var content = link.import;
  var el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  /**
   * Imports Button HTML into DOM of pages using it.
   *
   * @type {Element}
   */
  link = document.querySelector('link[href="src/partials/confirm-button.html"]');
  content = link.import;
  el = content.querySelector('script');
  document.querySelector('body').appendChild(el.cloneNode(true));

  // Place site data in table via site-listing template located in site-listing.html.
  let siteListing = new Vue({
    el: '#site-listing',
    data: {
      searchQuery: '?where={"nodes_total":{"$gt":1}}',
      gridColumns: ['id', 'path', 'status', 'core', 'profile', 'packages', 'updated', 'created'],
      gridData: [],
      cachedRecords: [],
      editKeys: ['path', 'status'],
      selectKeys: ['status'],
      callback: 'updateSiteRecord',
      reset: false
    },
    created: function () {
      bus.$on('switchEnv', function (env) {
        getSiteRecords(siteConfig.atlasEnvironments[env])
          .then(function (data) {
            siteListing.gridData = data;
            // Cache the result until the next request.
            siteListing.cachedRecords = data;
          });
      })

      bus.$on('updateSiteRecord', function (params) {
        updateSiteRecord(params);
      });

      bus.$on('deleteRecord', function (params) {
        updateSiteRecord(params, 'DELETE');
      });

      // Set anything that needs updated when in edit mode.
      bus.$on('rowEdit', function (row) {
        // Add special edit content to the row key by key.
        row.editKeys.forEach(function (element, index) {
          // Need to set edit row options to nothing so they can render in component.
          let options = {
            rowId: row.data.id,
            rowKey: element,
            content: ''
          }
          store.commit('addEditContent', options)
        })
      })
    },
    computed: {
      showReset: function () {
        return siteListing.reset;
      }
    },
    watch: {
      // Update table with code data once site records have been loaded.
      gridData: function (siteRecords) {
        getCodeRecords(siteConfig.atlasEnvironments[localStorage.getItem('env')])
          .then(function (codeRecords) {

            let code = {
              cores: {},
              profiles: {},
              packages: {},
            }
            // Separate out code into profiles, cores, and packages.
            codeRecords.forEach(function (element, index) {
              if (element['code_type'] === 'profile') {
                code.profiles[element['label']] = element['id'];
              }

              if (element['code_type'] === 'core') {
                code.cores[element['label']] = element['id'];
              }

              if (element['code_type'] === 'module' || element['code_type'] === 'theme') {
                code.packages[element['label']] = element['id'];
              }
            })

            // Loop through site records to search for code.
            siteRecords.forEach(function (element, index) {
              if (typeof element['code']['core'] !== 'undefined') {
                let foundKeys = Object.keys(code.cores).filter(function(key) {
                  return code.cores[key] === element['code']['core'];
                })
                siteRecords[index]['core'] = foundKeys[0];
              }

              if (typeof element['code']['profile'] !== 'undefined') {
                let foundKeys = Object.keys(code.profiles).filter(function(key) {
                  return code.profiles[key] === element['code']['profile'];
                })
                siteRecords[index]['profile'] = foundKeys[0];
              }

              if (typeof element['code']['package'] !== 'undefined') {
                // Clear out packages first since we are pushing to an array.
                siteRecords[index]['packages'] = [];

                element['code']['package'].forEach(function (element2, index2) {
                  let foundKeys = Object.keys(code.packages).filter(function(key) {
                    return code.packages[key] === element2;
                  })
                  siteRecords[index]['packages'].push(foundKeys[0]);
                })
              }
            })

            Vue.set(siteListing.gridData, siteRecords)
            // Cache the result until the next request.
            Vue.set(siteListing.cachedRecords, siteRecords)

          });
      }
    },
    methods: {
      search: function (query) {

        // Make request to Atlas.
        let baseURL = siteConfig['atlasEnvironments'][localStorage.getItem('env')];
        let response = atlasRequest(baseURL, 'statistics', query);

        // Response is a Promise object so we must resolve it to get the data out.
        response.then(function (objects) {

          // Get array only of site IDs to check from stats query.
          let siteIds = [];
          objects.forEach(function (elements, index) {
            elements.forEach(function (element, index) {
              siteIds.push(element['site']);
            });
          });

          // Filter results by using the site ID stored in stats records.
          let queryResult = siteListing.cachedRecords.filter(function (row) {
            return siteIds.indexOf(row['_id']) > -1
          });

          // By setting the gridData property, the view will automatically update.
          siteListing.gridData = queryResult;
          siteListing.reset = true;
        });
      },
      resetSearch: function () {
        // By using the cached results when the page is loaded, the query can be reverted.
        siteListing.gridData = siteListing.cachedRecords;
        siteListing.searchQuery = '';
        siteListing.reset = false;
      }
    }
  });

  // Add create a site button to page.
  let siteCreateButton = new Vue({
    el: '#create-site',
    data: {
      label: 'Create A Site',
      callback: 'createSite',
    },
    created: function () {
      bus.$on('createSite', function (params) {
        createSite(params);
      });
    }
  });

  /**
   * Creates the list of site records based on the environment. Every time the environment
   * changes via the environment selector, the search will update.
   */
  $(document).ready(function () {
    let cachedRecords = {};
    getSiteRecords(siteConfig['atlasEnvironments'][localStorage.getItem('env')])
      .then(function (data) {
        siteListing.gridData = data;
        // Cache the result until the next request.
        siteListing.cachedRecords = data;
      });
  });
</script>
</body>
</html>
